#!/usr/bin/env bash

hst() { history | grep "$1"; }                          # Shorthand for `history` with added grepping
disk-usage() { du -hs "$@" | sort -nr; }              # List disk usage of all the files in a directory (use -hr to sort on server)
mktar() { tar cvzf "${1%%/}.tar.gz"  "${1%%/}/"; }    # Creates a *.tar.gz archive of a file or folder
mkzip() { zip -r "${1%%/}.zip" "$1" ; }               # Create a *.zip archive of a file or folder
ff () { /usr/bin/find . -name "$@" ; }                # ff:       Find file under the current directory
ffs () { /usr/bin/find . -name "$@"'*' ; }            # ffs:      Find file whose name starts with a given string
ffe () { /usr/bin/find . -name '*'"$@" ; }            # ffe:      Find file whose name ends with a given string
cd() { builtin cd "$@"; ll; }                         # Always list directory contents upon 'cd'

myjobs() {
    myjobs=$(jobs | wc -l);
    if [ $myjobs -ne 0 ]; then
        myjobs=$(echo -en "${GREEN}(${myjobs})${NORMAL}");
    else myjobs="";
    fi;
}

extract () {
	if [ -f $1 ] ; then
	  case $1 in
		*.tar.bz2)   tar xjf $1     ;;
		*.tar.gz)    tar xzf $1     ;;
		*.bz2)       bunzip2 $1     ;;
		*.rar)       unrar e $1     ;;
		*.gz)        gunzip $1      ;;
		*.tar)       tar xf $1      ;;
		*.tbz2)      tar xjf $1     ;;
		*.tgz)       tar xzf $1     ;;
		*.zip)       unzip $1       ;;
		*.Z)         uncompress $1  ;;
		*.7z)        7z x $1        ;;
		*)     echo "'$1' cannot be extracted via extract()" ;;
		 esac
	 else
		 echo "'$1' is not a valid file"
	 fi
}

multiextract () {
	for archive in $*; do
		if [ -f $archive ] ; then
			case $archive in
				*.tar.bz2)   tar xvjf $archive    ;;
				*.tar.gz)    tar xvzf $archive    ;;
				*.bz2)       bunzip2 $archive     ;;
				*.rar)       rar x $archive       ;;
				*.gz)        gunzip $archive      ;;
				*.tar)       tar xvf $archive     ;;
				*.tbz2)      tar xvjf $archive    ;;
				*.tgz)       tar xvzf $archive    ;;
				*.zip)       unzip $archive       ;;
				*.Z)         uncompress $archive  ;;
				*.7z)        7z x $archive        ;;
				*)           echo "don't know how to extract '$archive'..." ;;
			esac
		else
			echo "'$archive' is not a valid file!"
		fi
	done
}


# Function for determining the size of a git repository
gsize() {
  git gc
  size=$(git count-objects -vH | grep size-pack | awk '{ print $2, $3 }' | xargs)
  echo 'Repo size: $size'
}

# Common setup that applies to all environments
setup_common() {
  init_ssh
  wsl_only

  umask 027
}

# Remaps ssh to automatically start a tmux session on the remote server
txssh () {
  /usr/bin/ssh -t $@ "tmux attach || tmux new"
}

func_git_status() {
    STATUS=$(git status 2>/dev/null |
    awk '
    /^On branch / {printf($3)}
    /^You are currently rebasing/ {printf("rebasing %s", $6)}
    /^Initial commit/ {printf(" (init)")}
    /^Untracked files/ {printf(" |+ ")}
    /^Changes not staged / {printf(" |? ")}
    /^Changes to be committed/ {printf(" |* ")}
    /^Your branch is ahead of/ {printf(" |^ ")}
    /^fatal: not a git repository/ {printf("\|/")}
    ')
    if [ -n "$STATUS" ]; then
        echo -ne " ($STATUS) [$(git log 2> /dev/null | head -n 3 | grep ^Date | cut -f4- -d' ')]"
    fi
}

#startline="\[\033[0;32m\]\[\033[0m\033[0;38m\]\u\[\033[0;36m\]@\[\033[0;36m\]\h on ${_ip_add}:\w\[\033[0;32m\]"
#endline="\[\033[0;32m\]└─\[\033[0m\033[0;31m\] [\D{%F %T}] \$\[\033[0m\033[0;32m\] >>>\[\033[0m\] "
#PS1="${__ps1_startline} \$(__git_status)\n ${__ps1_endline}"

rightprompt()
{
    printf "%*s" $COLUMNS "right prompt"
}
#PS1='\[$(tput sc; rightprompt; tput rc)\]left prompt > '


function kcc () {
    usage () {
        echo -en "Usage: $0 <context> <namespace>\n"
    }
    result () {
        echo -en "-> Context: \e[96m$context\e[0m\n-> Namespace: \e[92m$namespace\n\e[0m"
    }
    if  [ $# -eq 0 ] ; then
        ## If no options, print the current context/cluster and namespace
        context="$(kubectl config current-context 2>/dev/null)"
        namespace="$(kubectl config view -o "jsonpath={.contexts[?(@.name==\"$context\")].context.namespace}")"
        result
    elif [ $# -eq 2 ]; then
        ## If options, assume time to set
        context="$1"
        namespace="$2"
        kubectl config use-context "$context" > /dev/null
        kubectl config set-context "$context" --namespace="$namespace" > /dev/null
        result
    else
        usage
    fi

}

# --- kubectl secrets ---
kgetsec () {

  if [[ -z "$1" ]]
  then
      kubectl get secrets
  elif [[ "$1" == "used" ]]
  then
     kubectl get pods -o json | jq '.items[].spec.containers[].env[]?.valueFrom.secretKeyRef.name' | grep -v null | sort | uniq
  else
    # display usage if wrong args are passed
    echo "Usage: kgetsec - Describes all secrets"
    echo "Parameters: "
    echo "   used - Shows curently used secrets by a pod"
    echo "Example:"
    echo "   kgetsec used"
  fi
}

# create secrets
create_sec_help() {
    case "$1" in
      args0)
       echo "Usage: kcreatesec - Create a secret with username and password"
       echo "Parameters: "
       echo "   -s - name of the secret"
       echo "   -u - username"
       echo "   -p - password"
       echo "Example:"
       echo "   kcreatesec -s secretname -u superuser -p superpassword"
       ;;
     args1)
       echo "Missing parameter. Please supply both username and passwords"
       echo "Usage: kcreatesec - Create a secret with username and password"
       echo "Parameters: "
       echo "   -s - name of the secret"
       echo "   -u - username"
       echo "   -p - password"
       echo "Example:"
       echo "   kcreatesec -s secretname -u superuser -p superpassword"
       ;;
     args2)
       echo "Incorrect parameters supplied."
       echo "Usage: kcreatesec - Create a secret with username and password"
       echo "Parameters: "
       echo "   -s - name of the secret"
       echo "   -u - username"
       echo "   -p - password"
       echo "Example:"
       echo "   kcreatesec -s secretname -u superuser -p superpassword"
       ;;
   esac
}

kcreatesec() {
    if [[ ("$#" -eq 0) || ("$1" == "help") ]]
    then
       create_sec_help "args0"
    elif [[ ("$#" -eq 1) ]]
    then
       create_sec_help "args1"
    elif [[ ("$3" != "-u") || ("$5" != "-p") ]]
    then
       create_sec_help "args2"
    fi
    while getopts "s:u:p:" opt; do
       case "$opt" in
          s) secret_name="$OPTARG"
            ;;
          u) user_name="$OPTARG"
            ;;
          p) password="$OPTARG"
            ;;
          \?) create_sec_help "args2"
        esac
     done
cat <<EOF > "${secret_name}".yml
apiVersion: v1
kind: Secret
metadata:
  name: ${secret_name}
type: Opaque
data:
  password: $(echo -n ${user_name} | base64)
  username: $(echo -n ${password} | base64)
EOF
echo "${secret_name}.yml file has been created in current directory."
echo "Creating the secret from ${secret_name}.yml"
kubectl create -f ${secret_name}.yml

}

# --- kubectl edit ---
kedit () {

   case "$1" in
      svc)
         if [[ ("$2" != "help") && (-z "$3") ]]
         then
             kubectl edit svc
         elif [[ "$1" == "help" && (-z "$3") ]]
         then
            echo "Usage: kedit svc service-name - Edit a service with default editor"
            echo "Parameters: "
            echo "   editor - Edit a service with an editor of your choice"
            echo "Example:"
            echo "   kedit svc nano service-name"
         else
            KUBE_EDITOR="$2" kubectl edit svc
         fi
         ;;
      dep)
         if [[ ("$2" != "help") && (-z "$3") ]]
         then
             kubectl edit svc
         elif [[ "$1" == "help" && (-z "$3") ]]
         then
            echo "Usage: kedit dep deployment-name - Edit a deployment with default editor"
            echo "Parameters: "
            echo "   editor - Edit a deployment with an editor of your choice"
            echo "Example:"
            echo "   kedit dep nano deployment-name"
         else
            KUBE_EDITOR="$2" kubectl edit deployment
         fi
         ;;
      *)
        echo "============================"
        echo "Edit a service or deployment"
        echo "============================"
        echo "Usage: kedit svc/dep service-name/deployment-name - Edit a deployment/service with default editor (VIM FTW)"
        echo " "
        echo "Parameters: "
        echo "   editor - Edit a service/deployment with an editor of your choice"
        echo "Example:"
        echo "   kedit svc nano service-name"
        echo "   kedit dep nano deployment-name"
   esac
}

gitlog () {
    err() {
        echo -e "\e[01;31m$@\e[0m" >&2
    }
    helpme () {
        err "  GIT LOGS______________________"
        err "    USAGE: gitlog [from_commit] [to_commit]"
        err "           gitlog HEAD^ HEAD"
        err "           gitlog branch1 branch2"
    }
    cmt1=$1
    cmt2=$2
    [ -z $cmt1 ] && [ -z $cmt2 ] && \
        run=1 && \
        git log --pretty=format:"%h%x09%an%x09%ad%x09%s"
    [ $cmt1 ] && [ $cmt2 ] && \
        run=1 && \
        git log --pretty=format:"%h%x09%an%x09%ad%x09%s" $cmt1..$cmt2
    [ -z $run ] && helpme
    unset cmt1 cmt2 run
}

gl() {
    if (( $# == 0 )); then
        git log --pretty=format:%h%x09%an%x09%ad%x09%s
    elif (( $# == 2 )); then
        git log --pretty=format:%h%x09%an%x09%ad%x09%s "$1".."$2"
    else
        printf '\e[01;31m%s\e[0m\n' \
            '  GIT LOGS______________________' \
            '    USAGE: gl [from_commit] [to_commit]' >&2
    fi
}

# Local additions - Don't edit below this line
if [[ -f ".functions.local" ]]; then
  source ".functions.local"
fi
